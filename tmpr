#!/usr/bin/env python
from __future__ import print_function

import re
import os
import sys
import json
import base64
import string
import random
import argparse
import webbrowser
import requests
import urllib

import tornado.web
import tornado.ioloop

try:
    import urlparse
    from urllib import urlencode
except:
    import urllib.parse as urlparse
    from urllib.parse import urlencode

#=============================================================================
# web server functions and data
#=============================================================================
# set the root directory for data, by default we should only be working in the
# current directory where this python file lives
ROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'files')
CHARS = string.ascii_lowercase + ''.join(map(str, range(10)))

FAVICON =  "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAGBQTFRFooKnN8jxY5PVM7vvM7zwY5LUN8fxo4KnhInAuX2Py3172oZtSZ/k5ZJjOa7s6pxbP9LyTNjy66VYVtryo4Vmqoxo57Fit5djvp1lw6Jnzaps17Fu3bNt47Rp6a1csZJmx8KbeAAAAEJJREFUOMtjEBGVl5cXl5CUkpaRlRWTkxPi5+Xm4mTgYOXhY2YTEBRmGNEK2EcVEKuAiRgFjFRXIEOqApZRBSQoAAAJHkuVEmG+EwAAAABJRU5ErkJggg=="

INDEX_CONTENT = \
string.Template("""
<link id="favicon" rel="shortcut icon" type="image/png"
 href="data:image/png;base64,$favicon">

<html><head><title>tmpr : file share</title></head>
<body style='background:url(data:image/png;base64,$favicon);background-size: 100% auto;'>
<center><pre style='font-size:48px;margin:10px;'>TMPR : FILE SHARING</pre></center>
<pre style='width:640px;margin:auto;background-color:rgba(255,255,255,0.5);padding:10px;'>
Temporary file sharing using simple two digit codes (1296 unique). Each file
can have a max number of downloads and password associated with it, defaults
are 1 download and no password. Max upload size of 128M.

GET
    /               -- this information
    /CODE?ARGS      -- get a file given by CODE

    ARGS (optional) :
        key - password associated with the file
        v - view contents on website rather than raw download

    Examples :
        curl http://URL/ui
        curl http://URL/ab?key=supersecretpassword
        firefox http://URL/7e?v

POST
    /?ARGS          -- upload a file and receive a name
    /CODE?ARGS      -- upload file to a particular name

    ARGS (optional) :
        key -- set a password for a particular file
        n   -- set number of times a file can be downloaded

    Example :
        curl -XPOST -F file=@filename http://URL/?key=secretpassword&n=3

# function for .bashrc to simplify upload
function tmpr() { curl -X POST -F file=@"$$1" &lt;URL&gt; }
</pre>
<br/><center>
<form enctype="multipart/form-data" action='/' method='post'>
n: <input type='text' name='n' style='width:20px;text-align:right;' value=1>
<input type='submit' value='Upload'><input type='file' id='filearg' name='filearg'>
</form></center>
<!--<script type='text/javascript>
document.getElementById("filearg").onchange = function() {
    document.getElementById("form").submit();
};
</script>-->
</body></html>
""").substitute(favicon=FAVICON)

#=============================================================================
# The actual web application now
#=============================================================================
class Application(tornado.web.Application):
    def __init__(self):
        handlers = [(r"/([a-z0-9]{2})?", MainHandler)]
        super(Application, self).__init__(handlers, gzip=True)

class MainHandler(tornado.web.RequestHandler):
    def prepare(self, *args, **kwargs):
        self.request.connection.set_max_body_size(int(1e8))
        super(MainHandler, self).prepare(*args, **kwargs)

    def generate_name(self):
        return ''.join([random.choice(CHARS) for i in range(2)])

    def unique_name(self):
        tries, out = 0, self.generate_name()
        while self.exists(out):
            if tries < len(CHARS)**2:
                raise Exception

            out = self.generate_name()
            tries += 1
        return out

    def path(self, n):
        return os.path.join(ROOT, n)

    def pathj(self, n):
        return os.path.join(ROOT, '{}.json'.format(n))

    def save_file(self, name, content, meta):
        with open(self.path(name), 'w') as f:
            f.write(content)

        with open(self.pathj(name), 'w') as f:
            f.write(json.dumps(meta))

    def open_file(self, name):
        data = open(self.path(name)).read()
        meta = json.loads(open(self.pathj(name)).read())
        return data, meta

    def delete_file(self, name):
        os.remove(self.path(name))
        os.remove(self.pathj(name))

    def exists(self, name):
        return os.path.isfile(self.path(name))

    def error(self, text):
        self.clear()
        self.set_status(404)
        self.write(text)
        self.finish()

    def serve_file_headers(self, meta):
        self.set_header('Content-Type', meta['content_type'])
        self.set_header('Content-Disposition', 'attachment; filename=' + meta['filename'])

    def serve_file(self, data, meta):
        self.serve_file_headers(meta)
        self.write(data)

    def write_formatted(self, data, meta):
        typ = meta['content_type']

        if 'image' in typ:
            self.write("<img src='data:%s;base64,%s'/>" % (typ, base64.b64encode(data)))
        elif 'text' in typ:
            self.write('<pre>%s</pre>' % data)
        else:
            self.serve_file(data, meta)

    def get(self, args):
        agent = self.request.headers['User-Agent']

        if not args:
            self.write(INDEX_CONTENT)
            self.finish()
        else:
            if not self.exists(args):
                self.error('not found')
                return

            data, meta = self.open_file(args)

            # check the key is present if required
            if meta['key']:
                if not meta['key'] == self.request.arguments.get('key', [''])[0]:
                    self.error('key invalid')
                    return

            # either delete the file or update the view count in the meta data
            meta['n'] -= 1
            if meta['n'] == 0:
                self.delete_file(args)
            else:
                self.save_file(args, data, meta)

            # if we are on command line, just return data, otherwise display it pretty
            if 'curl' in agent or 'Wget' in agent:
                self.write(data)
            elif 'v' in self.request.arguments.keys():
                self.write_formatted(data, meta)
            else:
                self.serve_file(data, meta)
            self.finish()

    def post(self, args):
        meta = {}
        meta['key'] = self.request.arguments.get('key', [None])[0]
        usern = int(self.request.arguments.get('n', [1])[0])
        usern = max(min(usern, 10), 0)
        meta['n'] = usern

        # change to error occured since file already exists
        if args and self.exists(args):
            self.error('exists')
            return

        if len(self.request.files) == 1:
            # we have files attached, save each of them to new file names
            name = args or self.unique_name()
            fobj = self.request.files.values()[0][0]

            # separate the actual contents from the meta data
            body = fobj.pop('body')
            meta.update(fobj)

            # write the file and return the accepted name
            self.save_file(name, body, meta)
            self.write(name)
            self.finish()
            return

        self.error('improper payload')

#=============================================================================
# command line utility features
#=============================================================================
def conf_file():
    return os.path.expanduser('~/.tmpr.json')

def argformat(d):
    out = {k:v for k,v in d.items() if v}
    return '?'+urlencode(out) if out else ''

def conf_read(key):
    filename = conf_file()
    if os.path.exists(filename):
        return json.load(open(filename)).get(key)
    return {}

def conf(url='', password=''):
    filename = conf_file()
    if os.path.exists(filename):
        cf = json.load(open(filename))
    else:
        cf = {}

    if url:
        cf.update({'url': url})
    if password:
        cf.update({'pass': password})
    json.dump(cf, open(filename, 'w'))

def download(url, code, password='', browser=False):
    """ Download a file 'code' from the tmpr 'url' """
    url = url or conf_read('url')
    password = password or conf_read('pass')

    arg = argformat({'key': password})
    rqt = '{}{}'.format(urlparse.urljoin(url, code), arg)

    if browser:
        webbrowser.open(rqt, new=True)
        return

    response = requests.get(rqt)

    # if we get an error, print the error and stop
    if response.status_code != 200:
        print("Code '{}' not found at '{}', '{}'".format(code, url, response.content.decode('utf-8')))
        sys.exit(1)

    headers = response.headers
    contents = response.content
    response.close()

    filename = re.match('.*filename=(.*)$', headers['Content-Disposition']).groups()[0]

    # make sure we are not overwriting any files by appending numbers to the end
    if os.path.exists(filename):
        for i in range(1000):
            newname = '{}-{}'.format(filename, i)
            if not os.path.exists(newname):
                filename = newname
                break

    with open(filename, 'wb') as f:
        f.write(contents)

def upload(url, filename, code='', password='', num=None):
    """ Upload the file 'filename' to tmpr url """
    url = url or conf_read('url')
    password = password or conf_read('pass')

    url = url if not code else urlparse.urljoin(url, code)
    arg = {} if not password else {'key': password}
    arg = arg if num == 1 else dict(arg, N=num)

    name = os.path.basename(filename)

    if not os.path.exists(filename):
        print("File '{}' does not exist".format(filename))
        sys.exit(1)

    with open(filename) as f:
        r = requests.post(url, data=arg, files={name: f.read()})
        print(r.content.decode('utf-8'))

#=============================================================================
# command line parsing and main
#=============================================================================
class ShortFormatter(argparse.HelpFormatter):
    def _format_action_invocation(self, action):
        if not action.option_strings:
            default = self._get_default_metavar_for_positional(action)
            metavar, = self._metavar_formatter(action, default)(1)
            return metavar

        else:
            parts = []

            # if the Optional doesn't take a value, format is:
            #    -s, --long
            if action.nargs == 0:
                parts.extend(action.option_strings)

            # if the Optional takes a value, format is:
            #    -s ARGS, --long ARGS
            else:
                default = self._get_default_metavar_for_optional(action)
                args_string = self._format_args(action, default)
                for option_string in action.option_strings:
                    parts.append(option_string)

                return '%s %s' % (', '.join(parts), args_string)
            return ', '.join(parts)

    def _get_default_metavar_for_optional(self, action):
        return action.dest.upper()

    def _get_default_metavar_for_positional(self, action):
        return action.dest

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=
        "Simple file sharing utility with download limits and password protection",
        formatter_class=ShortFormatter
    )
    sub = parser.add_subparsers()

    # shared arguments between upload and download
    shared = argparse.ArgumentParser(add_help=False)
    shared.add_argument("-u", "--url", type=str, default='',
        help="URL of tmpr service with which to interact")
    shared.add_argument("-p", "--pass", type=str, default='',
        help="Password for uploaded file")

    # the sub actions that can be performed
    def _fmt(name):
        if sys.version_info[0] >= 3:
            return {'name': name, 'aliases': [name[0]]}
        return {'name': name[0]}
    kw = {'formatter_class': ShortFormatter}
    kw2 = dict(kw, parents=[shared])

    p_conf= sub.add_parser(help="configure defaults for tmpr", **dict(_fmt('conf'), **kw2))
    p_serve = sub.add_parser(help="run the tmpr.py webserver", **dict(_fmt('serve'), **kw))
    p_upload = sub.add_parser(help="upload a file to tmpr", **dict(_fmt('upload'), **kw2))
    p_download = sub.add_parser(help="download an uploaded file", **dict(_fmt('download'), **kw2))

    p_conf.set_defaults(action='conf')
    p_serve.set_defaults(action='serve')
    p_download.set_defaults(action='download')
    p_upload.set_defaults(action='upload')

    # custom arguments for server action
    p_serve.add_argument("-a", "--addr", type=str, default='127.0.0.1',
        help="interface / address on which to run the service")
    p_serve.add_argument("-p", "--port", type=int, default=3333,
        help="port on which to run the server")
    p_serve.add_argument("-r", "--root", type=str, default=ROOT,
        help="directory in which to store the uploaded files")

    # custom arguments for upload action
    p_upload.add_argument("-n", "--num", type=int, default=1,
        help="number of downloads available for this file")
    p_upload.add_argument("-c", "--code", type=str,
        help="optional code for uploaded file")
    p_upload.add_argument("filename", type=str, help="name of file to upload")

    # custom arguments for download action
    p_download.add_argument(
        "-b", "--browser", dest='browser', action='store_true',
        help="open the file in a browser"
    )
    p_download.add_argument("code", type=str, help="code of download file")

    args = vars(parser.parse_args())
    action = args.get('action')

    if action == 'serve':
        ROOT = args.get('root')
        if not os.path.exists(ROOT):
            os.mkdir(ROOT)

        app = Application()
        app.listen(args.get('port'), args.get('addr'))
        tornado.ioloop.IOLoop.instance().start()

    elif action == 'download':
        download(
            args.get('url'), args.get('code'), 
            password=args.get('pass'), browser=args.get('browser')
        )

    elif action == 'upload':
        upload(
            args.get('url'), args.get('filename'),
            code=args.get('code'), num=args.get('num'), password=args.get('pass')
        )

    elif action == 'conf':
        conf(
            url=args.get('url'), password=args.get('pass')
        )

    else:
        parser.print_help()
